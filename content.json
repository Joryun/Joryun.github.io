{"meta":{"title":"Joryun's Notes","subtitle":"多读书多看报少吃零食多睡觉","description":"TO BE IS TO DO","author":"刘家源","url":"http://joryun.com"},"pages":[{"title":"","date":"2019-06-09T08:11:09.976Z","updated":"2019-06-09T08:11:09.976Z","comments":true,"path":"about/index.html","permalink":"http://joryun.com/about/index.html","excerpt":"","text":"title: abouttype: “about”"},{"title":"","date":"2019-06-09T08:10:04.344Z","updated":"2019-06-09T08:10:04.342Z","comments":true,"path":"categories/index.html","permalink":"http://joryun.com/categories/index.html","excerpt":"","text":"title: categoriestype: “categories”"},{"title":"","date":"2019-06-09T08:10:30.918Z","updated":"2019-06-09T08:10:30.917Z","comments":true,"path":"tags/index.html","permalink":"http://joryun.com/tags/index.html","excerpt":"","text":"title: tagstype: “tags”"}],"posts":[{"title":"整理五道算法题系列：二叉树相关","slug":"整理五道算法题系列：二叉树相关","date":"2018-04-14T09:59:06.000Z","updated":"2020-03-30T15:25:05.788Z","comments":true,"path":"2018/04/14/整理五道算法题系列：二叉树相关/","link":"","permalink":"http://joryun.com/2018/04/14/整理五道算法题系列：二叉树相关/","excerpt":"","text":"背景整理几道有意思的题目，比较有趣的破题技巧与思想，均为学习笔记。~~ 说明=&gt; 五道 / 篇 =&gt; Java =&gt; 二叉树相关 题目1、重建二叉树输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 思路：首先得了解先序、中序的特点，接着从先序定位根，然后再去中序找出左右子树，依旧是递归实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public TreeNode reConstructBinaryTree(int[] pre, int[] in) &#123; return reConstructBinaryTree(pre, 0, pre.length - 1, in, 0, in.length - 1); &#125; /** * @param pre 前序 * @param startPre 前序首位 * @param endPre 前序末位 * @param in 中序 * @param startIn 中序首位 * @param endIn 中序末位 * @return */ public TreeNode reConstructBinaryTree(int[] pre, int startPre, int endPre, int[] in, int startIn, int endIn) &#123; // constraint if (startPre &gt; endPre || startIn &gt; endIn) &#123; return null; &#125; // 先序第一位即为根 TreeNode root = new TreeNode(pre[startPre]); for (int i = startIn; i &lt;= endIn; i++) &#123; // 中序找寻根所在位置 if (in[i] == pre[startPre]) &#123; /* 重点解析 1. startPre + i - startIn ： 根据中序所找到的根，从而得知下一次递归的左子树，接着找到 前序的左子树部分，再次根据前序“根左右”的特性传入startPre 和 endPre，而由于startPre每次都在向 右，因此endPre应该根据startPre来决定 2. (startPre + i - startIn) + 1 ：根据中序所找到的根，从而得知下一次递归的右子树，而上一步已 经在前序序列中分隔出根、左子树、右子树，那基本可以确定传入的数组下标 */ root.left = reConstructBinaryTree(pre, startPre + 1, startPre + i - startIn, in, startIn, i - 1); root.right = reConstructBinaryTree(pre, (startPre + i - startIn) + 1, endPre, in, i + 1, endIn); &#125; &#125; return root; &#125; private class TreeNode &#123; int val; TreeNode left; TreeNode right; public TreeNode(int val) &#123; this.val = val; &#125; &#125; 2、树的子结构输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构） 思路：土方法，一个个比较，但是递归比较，以B树为参考系，从根开始匹配。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public boolean HasSubtree(TreeNode root1, TreeNode root2) &#123; boolean result = false; if (root2 != null &amp;&amp; root1 != null) &#123; // 如果找到了对应Tree2的根节点的点 if (root1.val == root2.val) &#123; result = doesTree1HaveTree2(root1, root2); &#125; // 如果找不到，那么就再将root的左儿子当作起点，去判断时包含Tree2 if (!result) &#123; result = doesTree1HaveTree2(root1.left, root2); &#125; // 如果还找不到，那么就再将root的右儿子当作起点，去判断时候包含Tree2 if (!result) &#123; result = HasSubtree(root1.right, root2); &#125; &#125; return result; &#125; public boolean doesTree1HaveTree2(TreeNode node1, TreeNode node2) &#123; /* node1 和 node2 的为空判断务必得记住，一开始挺容易漏掉这个约束的！ */ // 如果Tree2已经遍历完了都能对应得上，返回true if (node2 == null) &#123; return true; &#125; // 如果Tree2还没遍历完，Tree1却遍历完了。返回false if (node1 == null) &#123; return false; &#125; // 如果其中有一个点没有对应上，返回false if (node1.val != node2.val) &#123; return false; &#125; // 如果根节点对应的上，那么就分别去子节点里面匹配 return doesTree1HaveTree2(node1.left, node2.left) &amp;&amp; doesTree1HaveTree2(node1.right, node2.right); &#125; private class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125; &#125; 3、镜像二叉树操作给定的二叉树，将其变换为源二叉树的镜像。输入描述： 思路：递归交换左右节点 12345678910111213141516171819202122232425public void Mirror(TreeNode root) &#123; TreeNode tmp; if (root != null) &#123; tmp = root.left; root.left = root.right; root.right = tmp; if (root.left != null) &#123; Mirror(root.left); &#125; if (root.right != null) &#123; Mirror(root.right); &#125; &#125; &#125; private class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125; &#125; 4、打印二叉树从上往下打印出二叉树的每个节点，同层节点从左至右打印。 思路：先序的遍历打印方式，巧妙运用Queue实现，利用其“先进先出”的特点。 123456789101112131415161718192021222324252627282930313233public ArrayList&lt;Integer&gt; PrintFromTopToBottom(TreeNode root) &#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); if (root == null) &#123; return list; &#125; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); queue.offer(root); /* while循环主要针对的是queue是否为空，而queue实际存储的是每层的根节点，因此便可每层按顺序存进list */ while (!queue.isEmpty()) &#123; TreeNode treeNode = queue.poll(); if (treeNode.left != null) &#123; queue.offer(treeNode.left); &#125; if (treeNode.right != null) &#123; queue.offer(treeNode.right); &#125; list.add(treeNode.val); &#125; return list; &#125; private class TreeNode &#123; int val = 0; TreeNode left = null; TreeNode right = null; public TreeNode(int val) &#123; this.val = val; &#125; &#125; 5、二叉搜索树的后序遍历序列输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。如果是则输出Yes,否则输出No。假设输入的数组的任意两个数字都互不相同。 思路：首先得了解二叉搜索树（BST），接着递归判断是否满足BST的条件。 12345678910111213141516171819202122232425262728293031public boolean VerifySquenceOfBST(int[] sequence) &#123; if (sequence.length == 0) &#123; return false; &#125; if (sequence.length == 1) &#123; return true; &#125; return judge(sequence, 0, sequence.length - 1); &#125; public boolean judge(int[] a, int start, int end) &#123; if (start &gt; end) &#123; return true; &#125; int i = start; /* 找寻左右子树的分界点 */ while (a[i] &lt; a[end]) &#123; ++i; &#125; for (int j = i; j &lt; end; j++) &#123; if (a[j] &lt; a[end]) &#123; return false; &#125; &#125; /* 递归，分出左右子树再次递归判断 */ return judge(a, start, i - 1) &amp;&amp; judge(a, i, end - 1); &#125;","categories":[{"name":"Algorithm","slug":"Algorithm","permalink":"http://joryun.com/categories/Algorithm/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"http://joryun.com/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"http://joryun.com/tags/算法/"},{"name":"二叉树","slug":"二叉树","permalink":"http://joryun.com/tags/二叉树/"}]},{"title":"小程序码生成及分享图绘制","slug":"小程序码生成及分享图绘制","date":"2018-01-13T08:20:05.000Z","updated":"2018-01-17T08:43:25.000Z","comments":true,"path":"2018/01/13/小程序码生成及分享图绘制/","link":"","permalink":"http://joryun.com/2018/01/13/小程序码生成及分享图绘制/","excerpt":"","text":"场景项目需求为用户创建活动，且生成了小程序码，进而再生成小程序码分享图，即在原小程序码的基础上绘制一张完整的分享图，并展示给用户进行分享。个中过程均交由后台生成并绘制（原因：用户在小程序直接点击某选项，直接转至分享图页面，而图片存储七牛云之上，若由前端生成再交由后台处理并返回，便影响响应速度） 说明开发环境：JDK1.8开发语言：Java 正题生成小程序码调用微信SDK，最好的文档便是官网文档了，虽然坑是真的多…进入正题！！！ 参考文档：https://mp.weixin.qq.com/debug/wxadoc/dev/api/qrcode.html 根据业务需求选择调用的相应接口，博主所做的小程序业务需求是用于临时场景，且需要多次分享、频繁分享，因此选了接口B类型。 步骤 看文档 坑点：1、注意场景值scene的说明，这个也很重要2、注意page参数的说明，“必须是已经发布的小程序页面”（之前做的小程序由于前期未通过审核没发布，很同意略过关键字眼。经验：未发布的小程序，无需传该参数，可正常获取小程序码，与scene不一样，scene会涉及后续的业务需求，里面的值会有具体的业务操作） 编码 说明：1、获取小程序码需要获取access_token。2、scene值需跟前端进行规约，具体的传值格式（以下代码scene值以加密形式传入，可自定义加密规则）3、以下 七牛上传 功能使用的便是博主介绍到的七牛云模块化，想了解的见上篇 《七牛云模块化文档》 123456789101112131415161718192021222324252627282930313233343536373839public String getminiqrQr(String sceneStr, String accessToken) &#123; RestTemplate rest = new RestTemplate(); InputStream inputStream = null; String path = null; try &#123; String url = \"https://api.weixin.qq.com/wxa/getwxacodeunlimit?access_token=\" + accessToken; Map&lt;String, Object&gt; param = new HashMap&lt;&gt;(); param.put(\"scene\", \"activity_\" + sceneStr);// param.put(\"page\", \"pages/Activity/Situation/Situation\"); param.put(\"width\", 200); logger.info(\"调用生成微信URL接口传参：\" + param); MultiValueMap&lt;String, String&gt; headers = new LinkedMultiValueMap&lt;&gt;(); org.springframework.http.HttpEntity requestEntity = new org.springframework.http.HttpEntity(param, headers); ResponseEntity&lt;byte[]&gt; entity = rest.exchange(url, HttpMethod.POST, requestEntity, byte[].class); logger.info(\"调用小程序生成微信小程序码URL接口返回结果：\" + entity.getBody()); byte[] result = entity.getBody(); logger.info(Base64.encodeBase64String(result)); inputStream = new ByteArrayInputStream(result); //七牛上传 path = qiniuService.uploadByStream(inputStream); logger.info(\"----------------path：&#123;&#125;\", path); &#125; catch (Exception e) &#123; logger.error(\"调用小程序生成微信小程序码URL接口异常\", e); &#125; finally &#123; if (inputStream != null) &#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return path; &#125; 以上最终便会返回小程序码的url，算挺简单的吧！ 绘制小程序码分享图效果如下： 说明1、使用awt在画布上一层层画上去，文字、图片均可以2、画上去的文字及图片有坐标的概念，需要底图和上层图片素材，以及坐标（用方形框住图片或文字，左上角即为原点，团队上的协作可交由设计人员给出即可） 编码 以下代码已附上注释，够详细了！ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public byte[] drawPicture(String backImg, String qrCodeImg, String kaiImg, String avatarImg,String activityText, String text1) throws IOException &#123; //底图 ClassPathResource redResource = new ClassPathResource(backImg); BufferedImage red = ImageIO.read(redResource.getInputStream()); //头像 URL avatarUrl = new URL(avatarImg); BufferedImage avatar = ImageIO.read(avatarUrl); //小程序码 URL qrCodeUrl = new URL(qrCodeImg); BufferedImage qrCode = ImageIO.read(qrCodeUrl); //开 ClassPathResource kaiResource = new ClassPathResource(kaiImg); BufferedImage kai = ImageIO.read(kaiResource.getInputStream()); //白底 ClassPathResource whiteResource = new ClassPathResource(\"white.jpeg\"); BufferedImage white = ImageIO.read(whiteResource.getInputStream()); // --- 画图 --- //底层空白 bufferedImage BufferedImage imgB = new BufferedImage(red.getWidth(), red.getHeight(), BufferedImage.TYPE_4BYTE_ABGR); //画上头像 drawImgInImg(imgB, avatar, 277, 90, 145, 145); //白底 drawImgInImg(imgB, white, 200, 400, 250, 250); //画上小程序码 drawImgInImg(imgB, qrCode, 255, 434, 190, 190); //画上图片 drawImgInImg(imgB, red, 0, 0, red.getWidth(), red.getHeight()); //画上开 drawImgInImg(imgB, kai, 309, 488, 83, 83); //写上文字，上 drawTextInImg(imgB, text1, 350, 315); //写上文字，活动 drawTextInImg(imgB, activityText, 350, 395); //转jpg BufferedImage result = new BufferedImage(imgB.getWidth(), imgB .getHeight(), BufferedImage.TYPE_3BYTE_BGR); result.getGraphics().drawImage(imgB, 0, 0, null); ByteArrayOutputStream bs = new ByteArrayOutputStream(); ImageIO.write(result, \"jpg\", bs); //最终byte数组 return bs.toByteArray(); &#125; 总结以上即为小程序码生成及绘制分享图的常见场景，在此基础上拓展出业务所需的功能，基本足够了！！！共勉~~~","categories":[{"name":"Coding","slug":"Coding","permalink":"http://joryun.com/categories/Coding/"}],"tags":[{"name":"微信","slug":"微信","permalink":"http://joryun.com/tags/微信/"},{"name":"小程序","slug":"小程序","permalink":"http://joryun.com/tags/小程序/"}]},{"title":"七牛云模块化","slug":"七牛云模块化","date":"2018-01-03T02:54:31.000Z","updated":"2018-01-17T08:38:07.000Z","comments":true,"path":"2018/01/03/七牛云模块化/","link":"","permalink":"http://joryun.com/2018/01/03/七牛云模块化/","excerpt":"","text":"前言闲来无事，搭建了个人私仓来放模块化项目，以便项目引入直接使用。关键是，模块化可以根据项目所需进行版本迭代，每一次的使用都是完善的根基，效果贼棒。 介绍七牛云是国内领先的企业级公有云服务商，致力于打造以数据为核心的场景化PaaS服务。围绕富媒体场景，七牛先后推出了对象存储，融合CDN加速，数据通用处理，内容反垃圾服务，以及直播云服务等。 而此次推出的模块化，目的是为了满足项目存储图片的需求，才有了此番封模块化的构思。 话不多说…进入主题吧！ 模块化说明文档一、上传交互方式(两种) 前端上传(推荐方式) 客户端在上传资源到七牛云前，要先从业务服务器获取一个有效的上传凭证Token，即请求相应项目的七牛云接口拿到Token，接着使用Token调用前端上传七牛云的api，上传文件至七牛云，返回数据(得到图片URl，即可传给后台存储)。 PS：如果有设置回调，则上传完成时七牛云存储会自动发起回调到指定的业务服务器。 后台上传 单图上传 &amp; 多图上传 老规矩，后台项目会依赖七牛云模块，前端需请求相应后台接口，参数传File文件(当多图片时为数组)，后台将会直接上传文件至七牛云，并存储至数据库。 二、配置需知 一般不变配置：accessKey，secretKey 可变配置：bucket，key，expires，policy，strict 三、返回token情况分析1.提供空间名bucket，其余默认1String getToken(String bucket) 2. 提供空间名bucket，上传指定key，其余默认1String getToken(String bucket, String key) 3. 提供空间名bucket，上传指定key，有效时长expires，上传策略policy（详见官方SDK上传策略）1String getToken(String bucket, String key, long expires, StringMap policy) 4. 提供空间名bucket，上传指定key，有效时长expires，上传策略policy，是否去除非限定的策略字段strict1String getToken(String bucket, String key, long expires, StringMap policy, boolean strict) 注：后期将会迭代部分七牛模块化会添加多种动态配置参数获取token，因此，暂时是默认参数获取token，不过，足够使用了。 模块化使用文档Maven依赖七牛云pom.xml 12345&lt;dependency&gt; &lt;artifactId&gt;qiniu&lt;/artifactId&gt; &lt;groupId&gt;com.yuan.module&lt;/groupId&gt; &lt;version&gt;1.0.0&lt;/version&gt;&lt;/dependency&gt; 注：随着七牛模块的迭代，version会不同，但我会实时更新文档，并注上各版本的迭代内容~~~ 配置文件application.yml 覆盖accessKey，secretKey，linkAddress，bucket。 按如下配置格式配置，填充相关信息即可。 1234567joryun: module: qiniu: bucket: xxx access-key: xxx secret-key: xxx link-address: xxx 注意 linkAddress为默认外链域名，项目需要配置，否则无法访问。(不同的bucket对应的外链也不同) 务必要覆盖如上配置，否则上传的图片资源，将会存在博主的七牛云上 坑点：bucket的创建需注意，可能会存在区域的问题，一般广东用户可选择创建“华南”地区 温馨提示：以上配置中，joryun 是博主的英文名，最好是copy到项目，免得拼错 API（接口调用）前端上传（推荐方式） 返回Token给前端 1http://server_name:port/api/module/qiniu/token 调用前端与七牛交互的API，带着Token凭证上传 后端上传（推荐方式） 单图上传 1http://server_name:port/api/module/qiniu/one Param：MultipartFile file （单个file） 多图上传 1http://server_name:port/api/module/qiniu/many Param：MultipartFile[] files （file数组） 后端文件上传，流方式 1http://server_name:port/api/module/qiniu/stream 后端文件上传，字节方式 1http://server_name:port/api/module/qiniu/byte 拓展小知识说明：项目中有引用 swagger 依赖的，在前后端分离的架构里，可能在七牛模块化的使用成本上比较高。问题在于，后台引入了模块化，但swagger文档里并无出现此接口，那就会加大时间上的沟通成本以及使用成本，实为不利。 小技巧：博主的七牛模块化已引入了 swagger 依赖，为了减少前后端开发人员使用成本，可进行如下配置，即可在 swagger 文档看到此接口。 123456789101112131415161718@Bean public Docket swaggerSpringMvcPlugin() &#123; Parameter parameter = new ParameterBuilder() .name(\"Authorization\") .description(\"token\") .modelRef(new ModelRef(\"string\")) .parameterType(\"header\") .required(false) .defaultValue(\"token \") .build(); return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .globalOperationParameters(Collections.singletonList(parameter)) .select() .apis(withClassAnnotation(Api.class)) .paths(paths()) .build(); &#125; 主要是这一句配置： 1.apis(withClassAnnotation(Api.class)) 解析： 每个Controller都会加上如下注解，因此可由传统的包扫描更改为注解扫描，于是便出现了七牛模块化的接口文档！1@Api(tags = \"xxx\") 总结个人的项目里，七牛模块化已基本足够使用了。按上面提供的使用文档引入模块化，可以很方便地存储图片（为什么一直说存储图片呢…因为做了好多项目，大多是存储图片需要）。好了，功能完善的项目并非一日功夫，需要时间一步步完善，但模块化绝对是很好的一个idea，甚至是思维。闲着没事做，封些模块化使用，可以一点点抽离项目服务，其实挺类似 服务提供者 暴露服务的。 互励共勉吧！！！","categories":[{"name":"Coding","slug":"Coding","permalink":"http://joryun.com/categories/Coding/"}],"tags":[{"name":"七牛","slug":"七牛","permalink":"http://joryun.com/tags/七牛/"},{"name":"模块化","slug":"模块化","permalink":"http://joryun.com/tags/模块化/"},{"name":"spring boot","slug":"spring-boot","permalink":"http://joryun.com/tags/spring-boot/"}]},{"title":"Linux进程监控 + 钉钉通知","slug":"Linux进程监控 + 钉钉通知","date":"2017-12-22T01:59:26.000Z","updated":"2018-01-17T08:36:21.000Z","comments":true,"path":"2017/12/22/Linux进程监控 + 钉钉通知/","link":"","permalink":"http://joryun.com/2017/12/22/Linux进程监控 + 钉钉通知/","excerpt":"","text":"进程监控脚本背景启动于正式服务器的项目，有时会因为某种因素，例如docker内存超限因而容器崩溃（前不久就遇过…），如服务器内存不足或IO读写异常而崩溃….等等等等。而这些原因，都可能影响到项目的正常运行，严重地将会被kill掉。那么，在服务器上弄一套进程监控方案就很有必要了！ 说明进程监控采用shell脚本的形式，结合日常开发使用的CI工具（如Jenkins），再通过Linux服务器的定时器，定时监控进程，当进程被killed，服务自动重启。 进程：shell script 集成：Jenkins 打包：Jar 简单介绍JenkinsJenkins 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。 进入主题注：install jenkins的过程暂不在本篇介绍，若有时间，会整理出来。 简单几句话带过： jenkins新建一个需持续集成的maven项目，然后配置了从git拉取源码之后，通过执行shell脚本打包到Linux服务器运行。 流程一、Jenkins shell脚本示例 12345PROJECT=online_storeMOD=cmsPORT=9065IP=xxxssh root@yyy sh -xe deploy-production.sh $PROJECT $JOB_NAME $MOD $PORT $IP 解析：xxx：根据需要传该参数，如远程打包到不同服务器上，内网 or 公网，对传输都会有影响，涉及的东西与本篇侧重点不一样，故不作拓展 yyy：这个IP务必是 deploy-production.sh 脚本所在的服务器，至关重要，影响着打包及进程监控，可理解为Jenkins持续集成到Linux服务器的入口 二、Linux服务器执行的初始脚本注：初始脚本，言下之意是Jenkins与Linux服务器交互的第一个脚本，其余操作包括监控都与初始脚本息息相关 由于是博主为公司持续集成写的脚本，涉及一些隐私，故不全贴出来，仅贴关键部分。 1、接收参数 12345PROJECT=$1JOB=$2MOD=$3PORT=$4IP=$5 2、主要流程代码根据企业需求不同而编写不同代码，关键执行代码如下： 1nohup /usr/bin/java -jar -Dsun.jnu.encoding=UTF8 -Dfile.encoding=UTF8 -Dspring.profiles.active=production,swagger$MOD $JOB.jar &gt;&gt; /dev/null 2&gt;&amp;1 &amp; 说明：可选择性开启swagger。 3、注意注意！！！监控代码执行语句… 1sh ~/monitor_exec.sh $PROJECT $JOB $MOD $PORT 解析：显而易见，执行 monitor_exec.sh 脚本。 三、监控脚本的初始脚本作用：将监控脚本写入定时器。 关键代码： 1234567891011121314151617#!/bin/shPROJECT=$1JOB=$2MOD=$3PORT=$4mkdir -p ~/cron/touch ~/cron/$PROJECT.cronfile=~/cron/$PROJECT.cronecho 'cron path：'$file;if test -s $file; then echo \"cron文件内容不为空\";else echo \"* * * * * sh /root/monitor.sh $PORT $PROJECT $MOD $JOB\" &gt;&gt; ~/cron/$PROJECT.cron crontab ~/cron/$PROJECT.cron 解析：中间echo的cron path路径，会输出到Jenkins日志里。目的是将执行 monitor.sh 写入服务器定时任务。cron规则就不介绍了，自定义即可。 说明：监控脚本的执行过程，应该加上日志输出，这是好习惯，以便做记录！ 四、重点：监控脚本关键代码 123456789101112131415161718192021#!/bin/shPID=`/usr/sbin/lsof -i:$1 | grep -E 'java|node' | awk '&#123;print $2&#125;'`PROJECT=$2MOD=$3JOB=$4mkdir -p ~/logtouch ~/log/$PROJECT.logif test -z \"$PID\"then echo '后台自启动' &gt;&gt; ~/log/$PROJECT.log nohup /usr/bin/java -jar -Dsun.jnu.encoding=UTF8 -Dfile.encoding=UTF8 -Dspring.profiles.active=test,swagger$MOD ~/$PROJECT/$JOB.jar &gt;&gt; /dev/null 2&gt;&amp;1 &amp; sleep 5 echo '启动成功！！！' &gt;&gt; ~/log/$PROJECT.logelse echo 'service has been started' &gt;&gt; ~/log/$PROJECT.logfi 解析：Jar包会运行于服务器的一个端口上，与其同时也会对应一个进程号，以一定的时间规则去检查进程号是否存在，判断不在自启动即可，逻辑很简单。 拓展部分：集成钉钉通知背景：进程被kill，若是企业开发人员想要知道被kill的原因，便会查看日志，而通知就很有必要了。由于博主所在企业使用钉钉工作，因此集成在钉钉机器人，可实时通知开发人员。 关键代码12345678910111213echo '钉钉通知开始' &gt;&gt; ~/log/$PROJECT.logcurl 'https://oapi.dingtalk.com/robot/send?access_token= xxx ' \\ -H 'Content-Type: application/json' \\ -d ' &#123;\"msgtype\": \"text\", \"text\": &#123; \"content\": \"钉钉--- jiayuan 监控测试，killed port：'$1'，project：'$PROJECT' has been killed，已重启\" &#125; &#125;' sleep 3 echo '钉钉通知结束' &gt;&gt; ~/log/$PROJECT.log 说明：xxx：填上对应钉钉机器人的access_token即可。 注：脚本现在还一直在迭代，为了让脚本更强大、更健壮，我也会一直持续地完善… 相关截图日志 钉钉通知 查看定时任务 总结好了，真真真好久没写博客了，最近有些许忙，虽然有好多好多新鲜玩意想写，但一直没机会分享！ 本篇依旧介绍一直以来颇有兴趣的服务器部分，但架构一个更完善、更健壮的开发体系，还有很多很多东西要学…","categories":[{"name":"Coding","slug":"Coding","permalink":"http://joryun.com/categories/Coding/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://joryun.com/tags/linux/"},{"name":"shell","slug":"shell","permalink":"http://joryun.com/tags/shell/"},{"name":"服务器","slug":"服务器","permalink":"http://joryun.com/tags/服务器/"}]},{"title":"Spring Data JPA坑点记录","slug":"Spring Data JPA坑点记录","date":"2017-12-22T01:58:37.000Z","updated":"2018-01-17T08:34:23.000Z","comments":true,"path":"2017/12/22/Spring Data JPA坑点记录/","link":"","permalink":"http://joryun.com/2017/12/22/Spring Data JPA坑点记录/","excerpt":"","text":"一、分页查询场景：动态查询，分页查询，根据传入不同的状态，分别查询不同数据表，并且在传入page对象之前用map进行VO转换。而pageable的使用地方不同影响到了分页数据的正确性，以此进行探讨。 pageable使用于new PageImpl&lt;&gt;中，且直到最后才将List -&gt; Page pageable使用于findAll()中 前提：Page对象封于VO内，返回数据包括了分页数据 12345678@ApiModelProperty(\"记录\")private Page&lt;ActivityRecordVO&gt; activityRecordVOList;@ApiModelProperty(\"数量\")private Integer num = 0;@ApiModelProperty(\"金额\")private BigDecimal totalMoney = BigDecimal.valueOf(0); 错误运用： 123456789101112131415161718192021List&lt;ActivityRecordVO&gt; activityRecordVOList = new ArrayList&lt;&gt;(); if (receiveSendRecordRequestVO.getSendOrReceiveType() == SendOrReceiveType.RECEIVE) &#123; List&lt;ChallengeRecord&gt; challengeRecordList = challengeRecordDao.findByUserIdAndDeleteType(userId, DeleteType.FALSE); if (!CollectionUtils.isEmpty(challengeRecordList)) &#123; activityRecordVOList = challengeRecordList.stream() .map(this::challengeRecordToActivityRecordVO) .collect(Collectors.toList()); &#125; &#125; else if (receiveSendRecordRequestVO.getSendOrReceiveType() == SendOrReceiveType.SEND) &#123; List&lt;Activity&gt; activityList = activityDao.findByUserIdAndDeleteType(userId, DeleteType.FALSE); if (!CollectionUtils.isEmpty(activityList)) &#123; activityRecordVOList = activityList.stream() .map(this::activityTOActivityRecordVO) .collect(Collectors.toList()); &#125; &#125; 12activityReceiveSendRecordVO.setActivityRecordVOList(new PageImpl&lt;&gt;(activityRecordVOList, pageable, activityRecordVOList.size())); 解析：传入的pageable只在set进VO的时候，用new PageIml将List转为page对象，前端报的问题 虽然总页数、总条数均为正确，但第一页的条数是全部 ，数据异常！ 正确参考做法： 采用Specifications先根据查询条件动态查询并map出相应分页对象(此块代码因需求而异)，这时 findAll 传入的pageable是生效的，便会显现正确的分页信息。 代码块参考： xxxCommonSpecUtil 是自封的specification工具类，与原生spring data jpa原生查询方法类似。12345678910111213141516Page&lt;ActivityRecordVO&gt; page = new PageImpl&lt;&gt;(activityRecordVOList, pageable, activityRecordVOList.size()); if (receiveSendRecordRequestVO.getSendOrReceiveType() == SendOrReceiveType.RECEIVE) &#123; Specifications&lt;ChallengeRecord&gt; spec = Specifications.where( challengeCommonSpecUtil.equal(\"userId\", userId)) .and(challengeCommonSpecUtil.equal(\"deleteType\", DeleteType.FALSE)); page = challengeRecordDao.findAll(spec, pageable).map(this::challengeRecordToActivityRecordVO); &#125; else if (receiveSendRecordRequestVO.getSendOrReceiveType() == SendOrReceiveType.SEND) &#123; Specifications&lt;Activity&gt; spec = Specifications.where( activityCommonSpecUtil.equal(\"userId\", userId)) .and(activityCommonSpecUtil.equal(\"deleteType\", DeleteType.FALSE)); page = activityDao.findAll(spec, pageable).map(this::activityTOActivityRecordVO); &#125; 注：activityReceiveSendRecordVO为封装的VO，包含了返回的Page对象1activityReceiveSendRecordVO.setActivityRecordVOList(page); 二、事务，更新实体，并查询场景：@Transactional事务，更新用户余额（处理并发问题），更新完毕返回VO带上用户剩余余额，但却非更新后的余额。 更新逻辑代码：1userWebService.updateBalanceAfterTransaction(userId, transactionRecordAddVO.getMoney(),user.getBalance()); 1234567@Transactional public void updateBalanceAfterTransaction(Integer userId, BigDecimal money, BigDecimal userBalance) &#123; int i = userDao.updateBalanceAfterTransaction(userId, money, userBalance); if (i == 0) &#123; throw new ValidationException(MessageCodes.TRANSACTION_RECEIVE_IS_ERROR); &#125; &#125; 123@Modifying @Query(value = \"update User u set u.balance = u.balance - ?2 where u.id = ?1 and u.balance = ?3\") int updateBalanceAfterTransaction(Integer userId, BigDecimal money, BigDecimal userBalance); 解析：在jpa中使用 @Modifying ，虽然事务已经能够更新，但是在循环更新的时候，执行modify语句后的查询的实体仍然是没有更新的。 执行完modifying query， EntityManager可能会包含过时的数据，因为EntityManager不会自动清除实体。只有添加clearAutomatically属性，EntityManager才会自动清除实体对象。 添加代码：1@Modifying(clearAutomatically = true) 改正后的示例代码：123@Modifying(clearAutomatically = true) @Query(value = \"update User u set u.balance = u.balance - ?2 where u.id = ?1 and u.balance = ?3\") int updateBalanceAfterTransaction(Integer userId, BigDecimal money, BigDecimal userBalance); 总结使用了这么长时间spring data jpa，觉得Specifications巨好用，也不容易出错，也是我喜欢的编码风格，而new PageImpl&lt;&gt;()这种简单粗暴的方法我一般都用在查询数据关联太多表的情况，在最后直接返回，更深层次的还需要再探讨！","categories":[{"name":"Coding","slug":"Coding","permalink":"http://joryun.com/categories/Coding/"}],"tags":[{"name":"spring","slug":"spring","permalink":"http://joryun.com/tags/spring/"},{"name":"spring data jpa","slug":"spring-data-jpa","permalink":"http://joryun.com/tags/spring-data-jpa/"}]},{"title":"三方银行微信支付流程及配置相关","slug":"三方银行微信支付流程及配置相关","date":"2017-10-22T08:42:38.000Z","updated":"2018-01-17T08:32:07.000Z","comments":true,"path":"2017/10/22/三方银行微信支付流程及配置相关/","link":"","permalink":"http://joryun.com/2017/10/22/三方银行微信支付流程及配置相关/","excerpt":"","text":"应用场景现在市面上的公众号h5页面大多接的是公众号支付，微信支付的流程大多还是类似的。而这次记录的是三方银行微信支付的流程，会有些许不一样。 微信公众号配置微信授权配置 进入具有微信支付权限的微信公众平台 基本配置，配置网页授权域名、JS接口安全域名 在服务端代码中编写”获取js-sdk授权凭据”的接口 编写 创建订单时调起三方银行微信支付的接口ps：与微信支付不一样的地方在于，返回微信支付请求信息中，还需要传appId给前端，这是个大坑！否则报的问题是”支付验证签名失效”！ 说明：由于接的是三方银行的微信支付，因此无需在微信商户平台进行相关配置，而需要在三方银行的微信开发配置那里进行配置。 三方银行商户平台商户管理 - 微信开发配置 配置JS API支付授权目录 说明：新增相关JS API支付授权域名(前提是在公众号那里配置的域名已经是通过备案的！)，所有需要支付请求的地址，都需要在支付授权目录下，域名需通过ICP备案，且URL需细化至二级或三级域名。 拓展关键词冻结金额，用户余额，订单微信支付金额，订单余额支付金额 三方银行微信支付，项目中涉及几个重要且容易搞混的东西，有需要的可以参考参考！ 情况分析： 余额足以付款情况分析将判断放在订单创建方法里，更新用户余额，将余额减去订单所需的余额支付金额。条件：避免并发出现错误，比如（1）用户的冻结金额不为空，而当上一订单回调成功后会扣除余额及冻结金额情况（2）用户申请退款，在该订单还没完成前，退款金额便退还至用户余额，此时用户余额被改变。因此加两个属性判定，余额是否还是原来的余额，冻结金额是否还是原来的冻结金额，可以保证订单创建，且调起支付时订单各项数据的统一性，保证订单金额不出错，大致适用于并发情况！ 余额不足以付款，存在微信支付金额及冻结金额情况分析（1）首先列出所有可能情况，填充订单实体几个字段，分别为余额付款金额，微信付款金额，总付款金额（2）更新冻结金额（3）微信支付，在回调成功方法里更新用户余额及冻结金额（也得考虑异常及并发情况） 此为博主项目上三方银行微信支付各异常情况分析及支付流程实操，因涉及相关企业信息，便不贴出代码交流，但大致的流程也已说明，一起交流！！！ 编程是一门事业。互励共勉！！！","categories":[{"name":"Coding","slug":"Coding","permalink":"http://joryun.com/categories/Coding/"}],"tags":[{"name":"微信","slug":"微信","permalink":"http://joryun.com/tags/微信/"},{"name":"三方服务","slug":"三方服务","permalink":"http://joryun.com/tags/三方服务/"}]},{"title":"企业项目之迁移正式服","slug":"企业项目之迁移正式服","date":"2017-10-15T09:27:10.000Z","updated":"2018-01-17T08:29:01.000Z","comments":true,"path":"2017/10/15/企业项目之迁移正式服/","link":"","permalink":"http://joryun.com/2017/10/15/企业项目之迁移正式服/","excerpt":"","text":"应用场景企业项目制作除了多分支开发外，通常也会使用CI来简化部署流程，提高部署效率，当然，流程也不能少了测试服。毕竟，bug乃家常便饭，联调必不可免，因此，开发至测试服并迁移到正式服的流程也必不可少。 测试服环境应用开发语言：Java服务器：ECS CentOS7CI：Jenkins容器引擎：Docker执行：Shell运行程序：Jar 正式服环境服务器：ECS CentOS7（正式服可考虑四核八G）CI：Jenkins容器引擎：Docker执行：Shell运行程序：Jar 迁移正式服 域名购买及备案 解析域名（可解析多个二级域名，应用于cms or web等等） 拿到新机 yum update JDK 安装Docker环境并启动（采用systemctl） 编写DockerFile，或依次pull MySQL，Redis，并Run，映射到相应端口（配置安全组） install Nginx 配置server映射到一开始解析的一级或二级域名 配置root（h5页面上传，可上传前端使用npm打包完成的xxx.js） 配置映射location，若为Spring or SpringBoot项目，可通过requestMapping的前半部分进行URL规则映射 打Jar包，可使用持续集成工具+shell脚本打包，至于会不会新版本的jar替换旧版本的jar，全看shell脚本写的好不好 后台执行jar，可采用nohup Java应用程序一定要记得加log，将日志也打到正式服上，因为…这是个好东西来着 常用检测：tail -xxx xxx.log / tail -f xxx.log 部署Jar包经常使用流程：ps xxx(-ef)|grep xxx -&gt; kill -9 port -&gt; nohup 若使用Swagger调试的可开启Api文档进行接口调用调试，若不使用，可采取postman等http请求调试工具 ╮(￣▽￣)╭至此，一个大致的正式服也基本可以跑起来了 总结折腾服务器是一件有趣的事情，毕竟可以前沿地接触一些新鲜的技术，可玩性很高，方案也多得多！！！本篇介绍的算是简略总结版，并无开展更多细节，闲下来了估计会出一份详尽版或折腾版。有兴趣的一起交流交流！！！ 编程是一门事业。互励共勉！！！","categories":[{"name":"Coding","slug":"Coding","permalink":"http://joryun.com/categories/Coding/"}],"tags":[{"name":"java","slug":"java","permalink":"http://joryun.com/tags/java/"},{"name":"shell","slug":"shell","permalink":"http://joryun.com/tags/shell/"},{"name":"服务器","slug":"服务器","permalink":"http://joryun.com/tags/服务器/"},{"name":"centos","slug":"centos","permalink":"http://joryun.com/tags/centos/"}]},{"title":"Java8：Lambda表达式","slug":"Java8：Lambda表达式","date":"2017-09-18T03:52:58.000Z","updated":"2020-03-30T15:24:57.019Z","comments":true,"path":"2017/09/18/Java8：Lambda表达式/","link":"","permalink":"http://joryun.com/2017/09/18/Java8：Lambda表达式/","excerpt":"","text":"为什么java还在变？“要么改变，要么衰亡”。有变化改进，并适应编程语言生态系统的气候，才能不被淘汰。语言需要不断改进以跟进硬件的更新或满足程序的期待，java必须添加新功能来改进，并且只有新功能被人使用，变化才有意义。自java8出现以来，lambda是最重要的特性之一，它可以让我们用简洁流畅的代码完成一个功能。很长一段时间，java被吐槽是冗余和缺乏函数式编程能力的语言，随着函数式编程的流行，java8中也引入了这种编程风格。在此之前我们会用匿名内部类干这些事，但这并不是好的做法！ Lambda为一等公民？我们注意到，编程语言的整个目的在于操作值，而这些值均称被为一等值(或一等公民)。编程语言中的其他结构也有助于我们表示值的结构，但在程序执行期间并不能传递，因而被称为二等公民。此时，Java8的设计者实践发现，让方法等概念作为一等值可以扩充程序员的工具库，从而引入运行时可传递方法的概念。接着，lambda登场了。 何为Lambda?简单理解，lambda表达式是一段可以传递的代码，它的核心思想是将面向对象中的传递数据变成传递行为。 在什么地方使用Lambda表达式？可以在函数式的接口上使用Lambda表达式。 何为函数式接口？ 函数式接口就是只定义一个抽象方法的接口。比如： 1234567891011public interface Comparator&lt;T&gt; &#123; int compare(T o1, T o2);&#125;public interface Runnable &#123; public abstract void run();&#125;public interface Callable&lt;V&gt; &#123; V call() throws Exception;&#125; lambda表达式可以让你直接以内联的形式为函数式接口的抽象方法提供实现，并把整个表达式作为函数式接口的实例。你也可以用匿名内部类完成同样的事，只不过比较笨拙。 @FunctionInterface此注解用于表示该接口会被设计为一个函数式接口，如果使用此注解但是接口中超过一个抽象方法，编译器将会返回一个提示原因的错误。 推开Lambda大门基础语法在lambda中我们遵循如下的表达式来编写：1(parameter) -&gt; expression 或者 (parameter) -&gt; &#123;statement;&#125; parameter:：参数列表。可为空，可为一个变量，也可以是多个变量。 expression：表达式。代码逻辑部分,是一行代码。 statement：代码片段。 Java中lambda表达式的格式：参数、箭头、主体(即表达式)。当一个动作实现无法用一行代码完成时，可以编写一段代码用 {} 包裹起来。如：1int sum = (x, y) -&gt; x + y; 这时候我们应该思考这段代码不是之前的x和y数字相加，而是创建了一个函数，用来计算两个操作数的和。后面用int类型进行接收，在lambda中为我们省略去了return(lambda已经隐式包含了return语句，也可以采用显式返回语句)。 使用函数式接口java8已经在java.util.function中定义了一套常用的函数式接口，来应用不同的lambda表达式。 Predicate 函数描述符为 (T) -&gt; boolean Consumer 函数描述符为 (T) -&gt; void Funciton 函数描述符为 (T) -&gt; R Supplier 函数描述符为 () -&gt; T UnaryOperator 函数描述符为 (T) -&gt; T BinaryOperator 函数描述符为 (T, T) -&gt; T BiPredicate 函数描述符为 (T, U) -&gt; boolean BiConsumer 函数描述符为 (T, U) -&gt; void BiFunction 函数描述符为 (T, U) -&gt; R IDEA查看函数式接口如下： 大致分类： 消费型接口示例123456public static void donation(Integer money, Consumer&lt;Integer&gt; consumer)&#123; consumer.accept(money); &#125;public static void main(String[] args) &#123; donation(1000, money -&gt; System.out.println(\"好心的麦乐迪为Blade捐赠了\"+money+\"元\")) ;&#125; 供给型接口示例12345678910public static List&lt;Integer&gt; supply(Integer num, Supplier&lt;Integer&gt; supplier)&#123; List&lt;Integer&gt; resultList = new ArrayList&lt;Integer&gt;() ; for(int x=0;x&lt;num;x++) resultList.add(supplier.get()); return resultList ;&#125;public static void main(String[] args) &#123; List&lt;Integer&gt; list = supply(10,() -&gt; (int)(Math.random()*100)); list.forEach(System.out::println);&#125; 函数型接口示例转换字符串为Integer123456public static Integer convert(String str, Function&lt;String, Integer&gt; function) &#123; return function.apply(str);&#125;public static void main(String[] args) &#123; Integer value = convert(\"28\", x -&gt; Integer.parseInt(x));&#125; 断言型接口示例筛选出只有2个字的水果1234567891011121314public static List&lt;String&gt; filter(List&lt;String&gt; fruit, Predicate&lt;String&gt; predicate)&#123; List&lt;String&gt; f = new ArrayList&lt;&gt;(); for (String s : fruit) &#123; if(predicate.test(s))&#123; f.add(s); &#125; &#125; return f;&#125;public static void main(String[] args) &#123; List&lt;String&gt; fruit = Arrays.asList(\"香蕉\", \"哈密瓜\", \"榴莲\", \"火龙果\", \"水蜜桃\"); List&lt;String&gt; newFruit = filter(fruit, (f) -&gt; f.length() == 2); System.out.println(newFruit);&#125; 理解示例编写一个函数式接口，输入一个年龄，判断这个人是否是成人。 123456789101112131415161718192021public class FunctionInterfaceDemo &#123; @FunctionalInterface interface Predicate&lt;T&gt; &#123; boolean test(T t); &#125; /** * 执行Predicate判断 * * @param age 年龄 * @param predicate Predicate函数式接口 * @return 返回布尔类型结果 */ public static boolean doPredicate(int age, Predicate&lt;Integer&gt; predicate) &#123; return predicate.test(age); &#125; public static void main(String[] args) &#123; boolean isAdult = doPredicate(20, x -&gt; x &gt;= 18); System.out.println(isAdult); &#125;&#125; 从这个例子我们很轻松的完成 是否是成人 的动作，其次判断是否是成人，在此之前我们的做法一般是编写一个 判断是否是成人 的方法，是无法将 判断 共用的。而在本例，你要做的是将 行为 (判断是否是成人，或者是判断是否大于30岁)传递进去，函数式接口即告诉你结果是什么。 学习文档Lambda官方文档：https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html Lambda中文文档：https://zhouyinyan.gitbooks.io/java8/content/ 愿全天下的代码均不负辛勤的程序员！ CSDN：Joryun’s CSDN 简书：简书","categories":[{"name":"Coding","slug":"Coding","permalink":"http://joryun.com/categories/Coding/"}],"tags":[{"name":"java8","slug":"java8","permalink":"http://joryun.com/tags/java8/"}]},{"title":"谈谈Java对象序列化","slug":"谈谈Java对象序列化","date":"2017-05-28T01:17:58.000Z","updated":"2018-01-17T08:17:25.000Z","comments":true,"path":"2017/05/28/谈谈Java对象序列化/","link":"","permalink":"http://joryun.com/2017/05/28/谈谈Java对象序列化/","excerpt":"前言创建对象时，只要我们需要，便会一直存在。而若是程序终止，那无论如何它都不会继续存在。但某些情况下，如果对象能够在程序不运行时仍能保存其信息，那将非常有用。这样，在下次运行程序时，该对象将被重建并且拥有的信息与在程序上次运行时它所拥有的信息相同。此时，对象序列化便隆重登场了…","text":"前言创建对象时，只要我们需要，便会一直存在。而若是程序终止，那无论如何它都不会继续存在。但某些情况下，如果对象能够在程序不运行时仍能保存其信息，那将非常有用。这样，在下次运行程序时，该对象将被重建并且拥有的信息与在程序上次运行时它所拥有的信息相同。此时，对象序列化便隆重登场了… 关于对象序列化当我们在内存中创建可复用的Java对象时，一般情况下会依赖于JVM的生命周期，即会随着JVM的停止而销毁。但Java对象序列化可实现JVM停止运行之后保存(持久化)指定的对象，并可随时读取该对象。 引用《Thinking in Java》里面的一段话：利用它(对象序列化)可以实现轻量级持久性，“持久性”意味着一个对象的生存周期并不取决于程序是否正在执行；它可生存于程序的调用之间。 解析对象序列化序列化分为两部分：序列化 和 反序列化 。 序列化：将数据分解成字节流，以便在文件或网络上传输。(即 Java Object 转成 byte[] ) 反序列化：打开字节流并重构对象，从而取出对象。(即 byte[] 转成 Java Object ) 一般用途1231. 将内存中的对象状态保存至文件或数据库2. 网络传输3. Java远程方法调用(RMI) 具体实例(一)将对象状态保存至文件或数据库实现 java.io.Serializable 接口12345678910File file = new File(\"person.out\"); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(file)); //创建一个写入指定OutputStream的ObjectOutputStream对象Person person = new Person(\"Hello\", 101, Gender.MALE); out.writeObject(person); //将指定的对象写入out.close(); ObjectInputStream in = new ObjectInputStream(new FileInputStream(file)); Object newPerson = in.readObject(); //从ObjectInputStream读取对象in.close(); System.out.println(newPerson); 分析：上述是网上常见的一个例子，非常简单。实现 Serializable 接口采用的是默认序列化机制，我们注意到以上例子使用了两个类 ObjectOutputStream 、ObjectInputStream ，该demo就是使用了 ObjectOutputStream 来持久化对象，而使用 ObjectInputStream 从文件中取出对象。 123影响序列化的因素：transient关键字(1) 当某个字段被声明为transient后，默认序列化机制就会忽略该字段。(2) 若是想运用其它方法来序列化这个标了transient的字段，则可以通过添加两个方法：writeObject()与readObject()。 实现 java.io. Externalizable 接口JDK中提供了另一个序列化接口——Externalizable ， Externalizable 继承于 Serializable ，序列化的细节需要程序员完成。使用该接口之后，之前基于 Serializable 接口的序列化机制就将失效。 123456789@Override public void writeExternal(ObjectOutput out) throws IOException &#123; &#125; @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; &#125; (二)使用 Protostuff 序列化库在开发项目中，序列化是经常需要处理的问题。不管是网络传输上用json、xml、对象序列化，还是缓存数据中的序列化，都是相当重要的。 前提以并发系统为例，使用 Redis 缓存存储数据时，若单单只使用JDK的序列化，效率会很低，对并发类系统造成的影响无法想象。而Google开发的一套序列化方案 Protostuff ，好处很多，独立于语言，独立于平台，重要的是效率相当高，使用 Protostuff 序列化后的字节大小是json的10分之一，xml的20分之一，是二进制序列化的10分之一。 目的以实际的并发系统为例，使用 Protostuff 框架进行序列化处理。 说明 开发环境：IDEA，Tomcat 软件环境：SpringMVC，Spring，MyBatis 模块描述：若缓存中有我们需要的对象，则取出来；若是没有，则存入缓存中( Redis ) 过程 序列化 1set Object() -&gt; 序列化 -&gt; byte[] 反序列化 1get -&gt; byte[] -&gt; 反序列化 -&gt; Object() 编码Maven引入 Protostuff123456789101112&lt;!-- protostuff序列化依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt; &lt;artifactId&gt;protostuff-core&lt;/artifactId&gt; &lt;version&gt;1.0.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.dyuproject.protostuff&lt;/groupId&gt; &lt;artifactId&gt;protostuff-runtime&lt;/artifactId&gt; &lt;version&gt;1.0.8&lt;/version&gt; &lt;/dependency&gt; 在Dao层缓存RedisDao中引入 Protostuffset Object() -&gt; 序列化 -&gt; byte[] 1234567//LinkedBuffer：缓存器byte[] bytes = ProtobufIOUtil.toByteArray(seckill, schema, LinkedBuffer.allocate(LinkedBuffer.DEFAULT_BUFFER_SIZE));//超时缓存int timeout = 60 * 60; //1小时String result = jedis.setex(key.getBytes(), timeout, bytes); get -&gt; byte[] -&gt; 反序列化 -&gt; Object() 123456789byte[] bytes = jedis.get(key.getBytes());//从缓存获取到if (bytes != null) &#123; //空对象 Seckill seckill = schema.newMessage(); ProtobufIOUtil.mergeFrom(bytes, seckill, schema); return seckill;&#125; 测试 结果表明，字节数被压缩得极小，在并发系统效率确实不错，很值得学习的一个序列化库！ 总结本博文的内容均为自己的总结，想深入学习的朋友可参考《Thinking in Java》和《Effective Java》，里面写的内容非常详细的。共勉！！ 愿全天下的代码均不负辛勤的程序员！ CSDN：Joryun’s CSDN 简书：简书","categories":[{"name":"Coding","slug":"Coding","permalink":"http://joryun.com/categories/Coding/"}],"tags":[{"name":"java","slug":"java","permalink":"http://joryun.com/tags/java/"},{"name":"序列化","slug":"序列化","permalink":"http://joryun.com/tags/序列化/"},{"name":"对象","slug":"对象","permalink":"http://joryun.com/tags/对象/"}]},{"title":"Java之普通web项目转换为Maven项目","slug":"Java之普通web项目转换为Maven项目","date":"2017-05-21T09:24:50.000Z","updated":"2018-01-17T08:16:38.000Z","comments":true,"path":"2017/05/21/Java之普通web项目转换为Maven项目/","link":"","permalink":"http://joryun.com/2017/05/21/Java之普通web项目转换为Maven项目/","excerpt":"前言网上有许多普通web项目转换为maven项目的博文，但由于项目的不同，所需的步骤及必须的转换步骤也不同。因此，本文章将以一个基于SpringMVC，Spring，Hibernate的商城项目为例，详述转换过程。 具体实例说明 开发环境：IDEA，MySQL 项目构建：暂无（已通过本文章成功转换为maven） 软件环境：SpringMVC，Spring，Hibernate 项目描述：商城系统 目的将普通Dynamic Web项目转换为Maven项目","text":"前言网上有许多普通web项目转换为maven项目的博文，但由于项目的不同，所需的步骤及必须的转换步骤也不同。因此，本文章将以一个基于SpringMVC，Spring，Hibernate的商城项目为例，详述转换过程。 具体实例说明 开发环境：IDEA，MySQL 项目构建：暂无（已通过本文章成功转换为maven） 软件环境：SpringMVC，Spring，Hibernate 项目描述：商城系统 目的将普通Dynamic Web项目转换为Maven项目 步骤前提转换之前将项目置于Github上，并clone到IDEA上，防止最后不成功而导致项目bug难以补救，毕竟git的revision功能相当棒呢！！ 1. 将项目初步convert为Maven项目选择 Add framework support ，并勾选导入“Maven”依赖 2. 备份lib接着移除lib，然后编写pom.xml看到下面的一大片“红”，勿担心，那只是你“颠覆世界”的第一步，千万不能退缩 接着备份lib，再移除项目的lib，将项目置于“空jar”状态 补充pom.xml的头，自动生成的会略掉好几项必须的配置 12345678&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.shop&lt;/groupId&gt; &lt;artifactId&gt;Shop&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;Shop Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; 接着是个体力活，进入每个java、properties、xml、jsp等文件使用Add Maven依赖方式自动导入（快捷键： alt+enter），当然前提是网速要好哈！ 经过上步，已经初步导入了大部份必需的依赖，接着，将一些其它依赖（可参考之前备份的lib）随之导入，千万别忽略这一步，因为类似 mysql-connector-java 等这些依赖一般是还未导入的！ 3. 将spring配置文件、数据库属性文件、日志配置文件等剪切至src/main/resources之下 若是里面配置文件的映射路径有差错，记得进入改正，idea下cmd+鼠标可测试大部份不正确的路径。 4.将原来放置在WebRoot路径下的文件（包括js，css，jsp等）都剪切至webapp文件夹之下，并删除WebRoot文件夹重要的是 WEB-INF 文件夹 5.重新部署并测试重新部署至 Tomcat（或Jetty） 测试效果。 基本上，到这一步离成功也就不远了（而我已经成功了）。若是…若是还有bug，多调调，看看日志，看看控制台输出，直至转换成功也不失为一次很棒的尝试。 若有不明白的参见商城系统：Shop 总结Maven是一套相当不错的软件项目管理工具，因此很多程序猿可能会频频遇到Dynamic Web项目转换Maven项目的情况，这时大家便可以学习起来，以备不时之需！共勉！！ 愿全天下的代码均不负辛勤的程序员！ CSDN：Joryun’s CSDN 简书：简书","categories":[{"name":"Coding","slug":"Coding","permalink":"http://joryun.com/categories/Coding/"}],"tags":[{"name":"java","slug":"java","permalink":"http://joryun.com/tags/java/"},{"name":"maven","slug":"maven","permalink":"http://joryun.com/tags/maven/"}]},{"title":"Spring全家桶：Spring JMS + ActiveMQ起步","slug":"Spring全家桶：Spring JMS + ActiveMQ起步","date":"2017-05-21T03:46:40.000Z","updated":"2020-03-30T15:24:19.003Z","comments":true,"path":"2017/05/21/Spring全家桶：Spring JMS + ActiveMQ起步/","link":"","permalink":"http://joryun.com/2017/05/21/Spring全家桶：Spring JMS + ActiveMQ起步/","excerpt":"前言说明开发环境：IDEA，Active MQ 项目构建：Maven 软件环境：Spring，Spring JMS，Active MQ 项目描述：Spring JMS与Active MQ进行通讯 目的入门Spring JMS、Active MQ，使用Spring JMS向Active MQ的Message Queue发消息和读消息。","text":"前言说明开发环境：IDEA，Active MQ 项目构建：Maven 软件环境：Spring，Spring JMS，Active MQ 项目描述：Spring JMS与Active MQ进行通讯 目的入门Spring JMS、Active MQ，使用Spring JMS向Active MQ的Message Queue发消息和读消息。 123PS：demo整合过程均亲测，按顺序编码已测试通过项目代码有注释，可供理清各个class和各个方法块及属性的作用。 编码1. 开启Active MQ服务 2. 使用maven导入依赖库pom.xml 123456789101112131415161718192021222324252627282930313233343536&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-all&lt;/artifactId&gt; &lt;version&gt;5.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jms&lt;/artifactId&gt; &lt;version&gt;4.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;4.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;4.0.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.xbean&lt;/groupId&gt; &lt;artifactId&gt;xbean-spring&lt;/artifactId&gt; &lt;version&gt;3.16&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 3. 创建application.properties，封装Message Queue的配置application.properties 12jms.broker.url=tcp://localhost:61616jms.queue.name=bar 4. JMS全局配置，配置与ActiveMQ的连接JMSConfiguration.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:amq=\"http://activemq.apache.org/schema/core\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://activemq.apache.org/schema/core http://activemq.apache.org/schema/core/activemq-core-5.8.0.xsd\"&gt; &lt;!-- 配置与ActiveMQ的连接 --&gt; &lt;bean class=\"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer\"&gt; &lt;property name=\"location\"&gt; &lt;value&gt;application.properties&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- Activemq connection factory --&gt; &lt;bean id=\"amqConnectionFactory\" class=\"org.apache.activemq.ActiveMQConnectionFactory\"&gt; &lt;constructor-arg index=\"0\" value=\"$&#123;jms.broker.url&#125;\" /&gt; &lt;property name=\"useAsyncSend\" value=\"true\" /&gt; &lt;/bean&gt; &lt;!-- ConnectionFactory Definition --&gt; &lt;bean id=\"connectionFactory\" class=\"org.springframework.jms.connection.CachingConnectionFactory\"&gt; &lt;constructor-arg ref=\"amqConnectionFactory\" /&gt; &lt;/bean&gt; &lt;!-- Default Destination Queue Definition--&gt; &lt;bean id=\"defaultDestination\" class=\"org.apache.activemq.command.ActiveMQQueue\"&gt; &lt;constructor-arg index=\"0\" value=\"$&#123;jms.queue.name&#125;\" /&gt; &lt;/bean&gt; &lt;!-- JmsTemplate Definition --&gt; &lt;bean id=\"jmsTemplate\" class=\"org.springframework.jms.core.JmsTemplate\"&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt; &lt;property name=\"defaultDestination\" ref=\"defaultDestination\"/&gt; &lt;/bean&gt; &lt;!-- Message Sender Definition --&gt; &lt;bean id=\"messageSender\" class=\"com.net.jms.MessageSender\"&gt; &lt;constructor-arg index=\"0\" ref=\"jmsTemplate\" /&gt; &lt;/bean&gt;&lt;/beans&gt; 分析： （1） 配置ActiveMQ提供的ActiveMQConnectionFactory （2） 配置一个Spring JMS提供的CachingConnectionFactory （3） 定义一个ActiveMQ Queue作为消息的接收Queue（即Destination） （4） 创建JmsTemplate （5） 自定义一个MessageSender，使用该JmsTemplate进行消息发送 5. 创建MessageSender，提供发送消息的服务MessageSender.java 123456789101112131415161718192021222324package com.net.jms;import org.springframework.jms.core.JmsTemplate;import org.springframework.stereotype.Component;/** * 发送消息的服务：发送字符串信息 */@Componentpublic class MessageSender &#123; private final JmsTemplate jmsTemplate; public MessageSender(JmsTemplate jmsTemplate) &#123; this.jmsTemplate = jmsTemplate; &#125; public void send(final String text) &#123; jmsTemplate.convertAndSend(text); System.out.println(\"send: \" + text); &#125;&#125; 作用：通过jmsTemplate发送一个字符串信息 6. 配置一个Listener来监听和处理当前的Message QueueJMSReceiver.xml 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!-- 配置一个Listener来监听和处理当前的Message Queue --&gt; &lt;!-- Message Receiver Definition --&gt; &lt;bean id=\"messageReceiver\" class=\"com.net.jms.MessageReceiver\" /&gt; &lt;bean class=\"org.springframework.jms.listener.SimpleMessageListenerContainer\"&gt; &lt;property name=\"connectionFactory\" ref=\"connectionFactory\"/&gt; &lt;property name=\"destinationName\" value=\"$&#123;jms.queue.name&#125;\"/&gt; &lt;property name=\"messageListener\" ref=\"messageReceiver\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 自定义了一个MessageListener，且使用Spring提供的SimpleMessageListenerContainer作为Container。 7. 创建MessageListener的具体实现MessageReceiver.java 12345678910111213141516171819202122232425262728293031323334package com.net.jms;import javax.jms.JMSException;import javax.jms.Message;import javax.jms.MessageListener;import javax.jms.TextMessage;/** * 消息侦听器：监听当前的Message Queue * 从Queue中读取消息，并输出到当前控制台中 */public class MessageReceiver implements MessageListener &#123; public void onMessage(Message message) &#123; if (message instanceof TextMessage)&#123; TextMessage textMessage = (TextMessage) message; try &#123; String text = textMessage.getText(); System.out.println(String.format(\"Received: %s\",text)); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125; catch (JMSException e)&#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 作用：从Queue中读取消息，并输出到当前控制台中。 8. 创建两个测试类，一个用于发送消息到ActiveMQ的MessageQueue中，一个用于从MessageQueue中读取消息SenderApp.java 12345678910111213141516171819202122232425262728293031323334353637383940414243package com.net;import com.net.jms.MessageSender;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;import org.springframework.util.StringUtils;import java.io.BufferedReader;import java.io.IOException;import java.io.InputStreamReader;/** * 发送消息到ActiveMQ的Message Queue */public class SenderApp &#123; public static void main(String[] args) throws IOException &#123; start(\"JMSConfiguration.xml\"); &#125; public static void start(String configLocation) throws IOException &#123; MessageSender sender = getMessageSender(configLocation); BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); System.out.println(\"Please input your message:\"); String text = br.readLine(); while (!StringUtils.isEmpty(text)) &#123; System.out.println(String.format(\"send message: %s\", text)); sender.send(text); text = br.readLine(); &#125; &#125; public static MessageSender getMessageSender(String configLocation) &#123; ApplicationContext context = new ClassPathXmlApplicationContext(configLocation); return (MessageSender) context.getBean(\"messageSender\"); &#125;&#125; ReceiverApp.java 123456789101112131415package com.net;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * 从Message Queue中读取消息 */public class ReceiverApp &#123; public static void main(String[] args) &#123; new ClassPathXmlApplicationContext(\"JMSConfiguration.xml\", \"JMSReceiver.xml\"); &#125;&#125; 9. 测试：运行SenderApp.java，在控制台输入消息，接着运行ReceiverApp.java，结果如下 总结到此，spring jms与activemq的通信就已经集成结束了。共勉！！！ 愿全天下的代码均不负辛勤的程序员！ CSDN：Joryun’s CSDN 简书：简书","categories":[{"name":"Coding","slug":"Coding","permalink":"http://joryun.com/categories/Coding/"}],"tags":[{"name":"java","slug":"java","permalink":"http://joryun.com/tags/java/"},{"name":"spring","slug":"spring","permalink":"http://joryun.com/tags/spring/"},{"name":"jms","slug":"jms","permalink":"http://joryun.com/tags/jms/"},{"name":"avtivemq","slug":"avtivemq","permalink":"http://joryun.com/tags/avtivemq/"}]},{"title":"Think in Java：对象篇","slug":"Think in Java：对象篇","date":"2017-05-09T15:56:18.000Z","updated":"2020-03-30T15:24:30.761Z","comments":true,"path":"2017/05/09/Think in Java：对象篇/","link":"","permalink":"http://joryun.com/2017/05/09/Think in Java：对象篇/","excerpt":"前言略读了一些内容，觉得还是不太适合初学者入门，倒适合一开始偏向于项目而后想回头重新拾回Java点点滴滴的猿们。以下总结的都是一些博主觉得有意思的解释，或者忘却了的知识点。正在学习或者已经读完的朋友们，互勉！！！","text":"前言略读了一些内容，觉得还是不太适合初学者入门，倒适合一开始偏向于项目而后想回头重新拾回Java点点滴滴的猿们。以下总结的都是一些博主觉得有意思的解释，或者忘却了的知识点。正在学习或者已经读完的朋友们，互勉！！！ 笔记1. 基类 导出类使基类与导出类产生差异的两种方法： 直接在导出类添加新方法 改变现有基类方法的行为，即覆盖 2. OOP “后期绑定” OOP中，程序直到运行时才能够确定代码的地址，所以当消息发送到一个泛化对象时，必须采用其它机制——后期绑定。 后期绑定：当向对象发送消息时，被调用的代码直到运行时才能确定。编译器确保被调用方法的存在，并对调用参数和返回值执行类型检查，但并不知道将被执行的确切代码。 3. 向上转型将导出类看做是它的基类的过程称为向上转型。 4. 单根继承结构的优点 保证所有对象都具备某些功能 解释：单根继承结构中的所有对象都具有一个共用接口，所以它们归根到底都是相同的基本类型。 使垃圾回收器的实现变得容易许多 解释：由于所有对象都保证具有其类型信息，因此回收器不会因无法确定对象的类型而陷入僵局。这对于系统级操作（如异常处理）显得尤其重要。 5. 参数化类型 参数化类型：是一个编译器可以自动定制作用于特定类型上的类。 Java SE5的重大变化之一就是增加了参数化类型，即泛型（in Java）。 6. 线程的基本解释通常，线程只是一种为单一处理器分配执行时间的手段。 7. 引用操纵对象一旦创建了一个引用，可使用new操作符实现与一个对象相关联。 8. 数据存储在什么地方 寄存器 这是最快的存储区，因为它位于不同于其他存储区的地方——处理器内部。但寄存器的数量极其有限，所以寄存器根据需求进行分配。你不能直接控制，也不能在程序中感觉到寄存器存在的任何迹象。 堆栈 位于通用RAM（随机访问存储器）中，但通过堆栈指针可从处理器那里获得直接支持，堆栈指针若向下移动，则分配新的内存；若向上移动，则释放那些内存，这是一种快速有效的分配存储方法，仅次于寄存器。创建程序时，Java系统必须知道存储在堆栈内所有项的生命周期，以便上下移动堆栈指针。这一约束限制了程序的灵活性，所以虽然某些Java数据存储于堆栈中——特别是对象引用，但是Java对象并不存储于其中。 堆 一种通用的内存池（也位于RAM区），用于存放所有的Java对象。堆不同于堆栈的好处是：编译器不需要知道存储的数据在堆里存活多长时间。因此，在堆里分配存储有很大的灵活性。当需要一个对象时，只需要new写一行简单的代码，当执行这行代码时，会自动在堆里进行存储分配，当然， 为这种灵活性必须付出相应的代价：用堆进行存储分配和清理可能比堆栈进行分配存储需要更多的时间。 非RAM存储 如果数据完全存活于程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在。其中两个基本的例子是流对象和持久化对象。在流对象中，对象转化成字节流，通常被发送给另一台机器。在持久化对象中，对象被存放于磁盘上，因此，即使程序终止，它们仍可以保持自己的状态。这种存储方式的技巧在于：把对象转化成可以存放在其他媒介上的事物，在需要时，可恢复成常规的、基于RAM的对象。 9. 包装器类Java语言是一个面向对象的语言，但是Java中的基本数据类型却是不面向对象的，这在实际使用时存在很多的不便，为了解决这个不足，在设计类时为每个基本数据类型设计了一个对应的类进行代表，这样八个和基本数据类型对应的类统称为包装类。 10. 对象的作用域Java对象不具备和基本类型一样的生命周期。当用new创建一个Java对象时，它可以存活于作用域之外。如： 123&#123; String s = new String(\"a String\");&#125; // End of scope 引用s在作用域终点就消失了。但s指向的String对象仍继续占据内存空间。 11. 初始化若类的某个成员是基本数据类型，即使没有进行初始化，Java也会确保它获得一个默认值。 注：确实初始化的方法不适用于局部变量。因此，若在某个方法内定义，则得到的可能是任意值，而不会被自动初始化为0。 12. “向前引用”某个类在发出调用的源文件中，而此时即可直接使用这个类，即使这个类在文件的后面才被定义（Java消除了所谓“向前引用”的问题）。 13. static尽管当static作用于某个字段时，肯定会改变数据创建的方式（因为一个static字段对每个类来说都只有一份存储空间，而非static字段则是对每个对象都有一个存储空间），但是如果static作用于某个方法，差别却没有那么大。static方法的一个重要用法就是在不创建任何对象的前提下就可以调用它。 愿全天下的代码均不负辛勤的程序员！ CSDN：Joryun’s CSDN 简书：简书","categories":[{"name":"Learning","slug":"Learning","permalink":"http://joryun.com/categories/Learning/"}],"tags":[{"name":"java","slug":"java","permalink":"http://joryun.com/tags/java/"},{"name":"thinking-in-java","slug":"thinking-in-java","permalink":"http://joryun.com/tags/thinking-in-java/"}]},{"title":"webservice(2)：体验查询号码归属地demo","slug":"webservice(2)：体验查询号码归属地demo","date":"2017-04-15T13:48:04.000Z","updated":"2020-03-30T15:24:08.322Z","comments":true,"path":"2017/04/15/webservice(2)：体验查询号码归属地demo/","link":"","permalink":"http://joryun.com/2017/04/15/webservice(2)：体验查询号码归属地demo/","excerpt":"前言对于webservice的介绍，本文就不再赘余讲述。详见文章 webservice:(1)新手搭建调用webservice那些坑 首先，先给出一个站点，该站点提供了许多webservice服务，可供调用测试。站点： http://www.webxml.com.cn/zh_cn/index.aspx","text":"前言对于webservice的介绍，本文就不再赘余讲述。详见文章 webservice:(1)新手搭建调用webservice那些坑 首先，先给出一个站点，该站点提供了许多webservice服务，可供调用测试。站点： http://www.webxml.com.cn/zh_cn/index.aspx 如上图所示，我们本文将测试归属地webservice。我们先查询该webservice相关服务。 大家可以在该文本框中输入手机号，userID忽略，点击调用即可查询手机归属地。接下来我们通过代码测试该ws。 注：请求方式有很多种，分别为post、get、soap、wsimport。在这里，使用wsimport方式请求！！！ 步骤1.记录所调用webservice的WSDL进入之前的站点，找到相应webservice，点击服务说明 以下即为相应WSDL，一份xml文档 copy该站点的URL，如下 1http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx?WSDL 2.使用JDK目录下的工具-wsimport，生成调用webservice相应的代码wsimport 是一个命令，jdk1.6及以上才可以使用，ws针对不同的语言都会有个wsimport命令，我们可以在自己安装的jdk的bin目录下找到这个 wsimport.exe ，正因为有了这个，所以我们可以在命令行中使用wsimport命令。输入以下命令，会在特定的包中生成java与class文件，接着将其copy至项目路径下即可。 1wsimport -s . -p ws.client.c http://ws.webxml.com.cn/WebServices/MobileCodeWS.asmx?WSDL Problem：在mac下的终端，若使用到了zsh，可能会出现以下情况。 这是由于 zsh 不兼容的问题！！！具体原因：因为zsh缺省情况下始终自己解释这个 .h，而不会传递给 find 来解释。解决方案：打开 terminal，在~/.zshrc中加入:setopt no_nomatch, 然后进行 *source .zshrc 命令即可 以下为copy入项目空间的示例图注：ws.client.test下的WebserviceTest为webservice测试类，暂时忽略。 这样就有了号码归属地查询这个ws服务相关的API了，且是通过官方的WSDL来生成的。接着，便是编写测试类测试功能了。 3.编写测试类测试1234567891011121314151617package ws.client.test;import ws.client.c.MobileCodeWS;import ws.client.c.MobileCodeWSSoap;public class WebserviceTest &#123; public static void main(String[] args) &#123; //获取一个webservice服务 MobileCodeWS ws = new MobileCodeWS(); //获取具体服务类型：get post soap1.1 and soap1.2 MobileCodeWSSoap wsSoap = ws.getMobileCodeWSSoap(); String address = wsSoap.getMobileCodeInfo(\"你的手机号码\", null); System.out.println(\"手机归属地信息：\"+ address); &#125;&#125; 测试结果示例 OK！！！到这里我们就体验完了该webservice。 总结：webservice中WSDL很重要，里面用xml描述了webservice的信息，所以我们可以通过解析WSDL来获取该webservice相关的API，然后在自己的项目中调用这些API即可调用该webservice。 愿全天下的代码均不负辛勤的程序员！ CSDN：Joryun’s CSDN 简书：简书","categories":[{"name":"Coding","slug":"Coding","permalink":"http://joryun.com/categories/Coding/"}],"tags":[{"name":"java","slug":"java","permalink":"http://joryun.com/tags/java/"},{"name":"webservice","slug":"webservice","permalink":"http://joryun.com/tags/webservice/"}]},{"title":"提高Github Clone速度","slug":"提高Github Clone速度","date":"2017-02-27T13:57:27.000Z","updated":"2018-01-17T08:17:33.000Z","comments":true,"path":"2017/02/27/提高Github Clone速度/","link":"","permalink":"http://joryun.com/2017/02/27/提高Github Clone速度/","excerpt":"前言以下操作均在mac下，当然，windows也类似。如题。使用git clone速度之慢，简直绝了。因此，在这里将提出一种较为简单的解决方法，有兴趣花丢丢时间折腾的朋友可以试试。 虽说git clone跟网速离不了干系（有些地区较快，有些地区较慢），但总体来说，大部分都在10KiB/s-20KiB/s之间，及其慢。若是需要clone大repo，那速度简直捉急。","text":"前言以下操作均在mac下，当然，windows也类似。如题。使用git clone速度之慢，简直绝了。因此，在这里将提出一种较为简单的解决方法，有兴趣花丢丢时间折腾的朋友可以试试。 虽说git clone跟网速离不了干系（有些地区较快，有些地区较慢），但总体来说，大部分都在10KiB/s-20KiB/s之间，及其慢。若是需要clone大repo，那速度简直捉急。 解决方案1. 用 git 内置代理，直接走系统中运行的代理工具中转，比如，你的 SS 本地端口是 1080（一般port均为1080），那么可以如下方式走代理：12git config --global http.proxy socks5://127.0.0.1:1080git config --global https.proxy socks5://127.0.0.1:1080 编辑.gitconfig文件 Enter之后进入vim，按i进行insert 按Esc退出，输入:wq保存 2. 此外，git clone或者git push特别慢，并不是因为 http://github.com 的这个域名被限制了。而是 http://github.global.ssl.fastly.Net 这个域名被限制了。那么可以在hosts文件里进行绑定映射。具体步骤如下：在terminal输入命令并输入开机密码，Enter确认 1sudo vi /etc/hosts 然后依旧在vim上编辑，命令如下 12151.101.72.249 http://global-ssl.fastly.Net192.30.253.112 http://github.com 保存之后就可以了。 接下来，你可以在clone一次，ssh或https协议都行，速度翻了好几倍！！！ 以下正是亲测的结果，速度已经到达了200多KiB/s！！！ 总结虽说是细节部分，但是随手优化，不仅能接触更多新奇的东西，还能提高效率，何乐而不为呢… 愿全天下的代码均不负辛勤的程序员！ CSDN：Joryun’s CSDN 简书：简书","categories":[{"name":"Coding","slug":"Coding","permalink":"http://joryun.com/categories/Coding/"}],"tags":[{"name":"github","slug":"github","permalink":"http://joryun.com/tags/github/"},{"name":"git","slug":"git","permalink":"http://joryun.com/tags/git/"}]},{"title":"Sublime Text 3(Mac版)常用插件篇","slug":"Sublime Text 3(Mac版)常用插件篇","date":"2017-02-05T08:57:40.000Z","updated":"2020-03-30T15:24:44.034Z","comments":true,"path":"2017/02/05/Sublime Text 3(Mac版)常用插件篇/","link":"","permalink":"http://joryun.com/2017/02/05/Sublime Text 3(Mac版)常用插件篇/","excerpt":"前言以下大部份插件Windows安装方法基本与Mac类似.首先，Sublime Text无疑是编程中一款强有力的工具，深受程序猿的喜爱，下面简单介绍下Sublime Text. 说明Sublime Text一款具有代码高亮、语法提示、自动完成且反应快速的编辑器软件，不仅具有华丽的界面，还支持插件扩展机制，用它来写代码，绝对是一种享受。","text":"前言以下大部份插件Windows安装方法基本与Mac类似.首先，Sublime Text无疑是编程中一款强有力的工具，深受程序猿的喜爱，下面简单介绍下Sublime Text. 说明Sublime Text一款具有代码高亮、语法提示、自动完成且反应快速的编辑器软件，不仅具有华丽的界面，还支持插件扩展机制，用它来写代码，绝对是一种享受。 接下来直接切入主题，安装过程并不重要，旨在于提高编程效率，因此不会列出众多方法，实在没那个必要.文章的最后提供Sublime Text 3(Mac版)破解版，可直接使用，若链接失效，可私聊. 安装Package Control首先通过快捷键 ctrl+` (~) 或者 View &gt; Show Console 打开控制台(注：安装有QQ输入法的这个快捷键会有冲突的，输入法属性设置-输入法管理-取消热键切换至QQ拼音)，输入以下代码，enter即可. 1import urllib.request,os; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); open(os.path.join(ipp, pf), 'wb').write(urllib.request.urlopen( 'http://sublime.wbond.net/' + pf.replace(' ','%20')).read()) 使用Package Control组件安装插件Cmd+Shift+P（菜单 – Tools – Command Paletter，Windows快捷键：Ctrl+Shift+P），输入 install 选中 Install Package 并回车，输入或选择你需要的插件回车就安装了（注意左下角的小文字变化，会提示安装成功），安装其它插件也类似. 常用插件推荐 Emmet——Emmet 官方提供的 Sublime Text 扩展；//即zencoding，写html先装这一个就够了 SublimeLinter——代码校验插件，支持 HTML、CSS、JS、PHP、Java、C++ 等16种语言； HTML5 Alignment——代码对齐插件 jQuery——代码智能提示插件-Git—整合 Git 功能的插件 LESS——LESS 代码高亮插件 JsFormat——JavaScript 代码格式化插件 LiveReload——让页面即时刷新 Pretty JSON——JSON美化扩展 Can I Use——查询 CSS 属性兼容情况 CoffeeScript——CoffeeScript 代码高亮，校验和编译等 ColorPicker——跨平台取色器插件 Sublime Text 3(Mac版)百度网盘 12URL：https://pan.baidu.com/s/1slW5AUDPassword：rpsu 总结插件可以根据开发类型选择性装特定的插件，毕竟Sublime Text只有拓展插件才能更加优雅地编程。此外，还需要熟记大部份常用的快捷键，才能大大提高编程效率。此文章隶属于教程篇，不足肯定是有的，但只要有钻研精神，相信大家可以在编程路上吸取更多经验。共勉之！！！ 愿全天下的代码均不负辛勤的程序员！ CSDN：Joryun’s CSDN 简书：简书","categories":[{"name":"Coding","slug":"Coding","permalink":"http://joryun.com/categories/Coding/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://joryun.com/tags/mac/"},{"name":"编辑器","slug":"编辑器","permalink":"http://joryun.com/tags/编辑器/"},{"name":"插件","slug":"插件","permalink":"http://joryun.com/tags/插件/"}]},{"title":"webservice(1)：新手搭建调用webservice那些坑","slug":"webservice(1)：新手搭建调用webservice那些坑","date":"2016-05-26T05:40:30.000Z","updated":"2020-03-30T15:23:52.950Z","comments":true,"path":"2016/05/26/webservice(1)：新手搭建调用webservice那些坑/","link":"","permalink":"http://joryun.com/2016/05/26/webservice(1)：新手搭建调用webservice那些坑/","excerpt":"前言今天主要和大家分享搭建java版webservice，以及php调用webservice遇到的一些坑。博客内容大部分纯手打，纯亲测。注：网上有很多使用Eclipse构建webservice的教程，不过配置较麻烦，而且最后可能还访问不了。因此，此博客采用MyEclipse搭建。需注意一点，MyEclipse10及以下的支持不了pattern库，因此发布的项目如果包含Pattern则无法支持，这也是博主换IDE的原因。","text":"前言今天主要和大家分享搭建java版webservice，以及php调用webservice遇到的一些坑。博客内容大部分纯手打，纯亲测。注：网上有很多使用Eclipse构建webservice的教程，不过配置较麻烦，而且最后可能还访问不了。因此，此博客采用MyEclipse搭建。需注意一点，MyEclipse10及以下的支持不了pattern库，因此发布的项目如果包含Pattern则无法支持，这也是博主换IDE的原因。 #说明 开发环境：MyEclipse2014，JAX-WS构建（容易使用），Tomcat 7何为WebService？它是一种构建应用程序的普遍模型,可以在任何支持网络通信的操作系统中实施运行;它是一种新的web应用程序分支，是自包含、自描述、模块化的应用，可以发布、定位、通过web调用。 WebService 是一个应用组件,它逻辑性的为其他应用程序提供数据与服务.各应用程序通过网络协议和规定的一些标准数据格式（Http，XML，Soap)来访问 WebService ,通过 WebService 内部执行得到所需结果. WebService 可以执行从简单的请求到复杂商务处理的任何功能。一旦部署以后，其他 WebService 应用程序可以发现并调用它部署的服务。 关键的技术和规则在构建和使用Web Service时,主要用到以下几个关键的技术和规则: XML:描述数据的标准方法. SOAP:表示信息交换的协议. WSDL:Web服务描述语言. UDDI:通用描述、发现与集成，它是一种独立于平台的，基于XML语言的用于在互联网上描述商务的协议. XML 可扩展的标记语言(XML)是Web service平台中表示数据的基本格式。除了易于建立和易于分析外，XML主要的优点在于它既是平台无关的，又是厂商无关的。无关性是比技术优越性更重要的：软件厂商是不会选择一个由竞争对手所发明的技术的。 SOAP SOAP是web service的标准通信协议，SOAP为simple object access protocoll的缩写，简单对象访问协议. 它是一种标准化的传输消息的XML消息格式。 WSDL WSDL的全称是web service Description Language,是一种基于XML格式的关于web服务的描述语言。其主要目的在于web service的提供者将自己的web服务的所有相关内容,如所提供的服务的传输方式，服务方法接口，接口参数，服务路径等，生成相应的完全文档，发布给使用者。使用者可以通过这个WSDL文档，创建相应的SOAP请求消息，通过HTTP传递给webservice提供者；web服务在完成服务请求后，将SOAP返回消息传回请求者，服务请求者再根据WSDL文档将SOAP返回消息解析成自己能够理解的内容。 UDDI 将web service进行UDDI注册发布,UDDI是一种创建注册表服务的规范,以便大家将自己的web service进行注册发布供使用者查找.然而当服务提供者想将自己的web service向全世界公布，以便外部找到其服务时，那么服务提供者可以将自己的web service注册到相应的UDDI商用注册网站，目前全球有IBM等4家UDDI商用注册网站。因为WSDL文件中已经给定了web service的地址URI，外部可以直接通过WSDL提供的URI进行相应的web service调用。所以UDDI并不是一个必需的web service组件，服务方完全可以不进行UDDI的注册。 具体实例(一) 开始搭建webservice前提首先安装好MyEclipse2014，保证jdk环境配置好了，有tomcat服务器（没有也没关系，MyEclipse自带MyEclipse Tomcat 7，亲测好用，默认端口为8080）。 创建发布webservice 配置Tomcat 部署项目并启动Tomcat服务器 添加JAX-WS库 测试webservice 编码1. 创建发布webservice新建Web Service Project 然后填好信息并next 然后接下来一直next，可选择生成web.xml.这是刚新建的项目结构 2. 然后新建一类文件UserInfo.java 示例源码： 123456789101112131415package com.yuan.webservice;/** * * @author Joryun * */public class UserInfo &#123; public String GetUserInfo()&#123; return \"源哥\"; &#125; public String ParameterTest(String user, String pwd)&#123; return user+\"：\"+pwd; &#125;&#125; 3. 接下来发布web service 4. 选择从java类创建web service 5. 选择访问的java class 6. 生成WSDL（WSDL以上有介绍，不懂可以回去看） 7. 发布后的项目结构如下 (二) 配置Tomcat前提假定你需要使用自己本机Tomcat的情况下 过程Window-Preferences-MyEclipse-Servers-Tomcat 配置好后Apply-OK. 部署项目并启动Tomcat服务器部署此项目到服务器 选择完后Finish 接下来启动Tomcat服务器 服务器已启动的图例 添加JAX-WS库在项目的构建路径中添加库文件 测试webservice输入URL，出现图式效果即为发布成功. 1http://localhost:8080/WebServiceDemo/UserInfoPort?wsdl PHP调用webservice说明博主采用CI框架测试，但不用框架也一样。并且php项目文件发布到了xampp上，直接访问本地即可查看效果。 123关于php调用webservice，亲测过两种方法：1. 引入nusoap.php，调用call()方法2. php5自带函数测试，classMap方式传值 1. 引入nusoap.php，调用call()方法特别注意：以下两处圈红圈的是坑点，一开始测试的时候用的是webservice接口名的参数，即user，pwd.但实际上打印到网页上之后才发现参数是arg0和arg1。。。 2. php5自带函数测试，classMap方式传值 以下贴PHP实现源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?phpheader('Content-Type: text/html; charset=UTF-8');/** * Class Test * Joryun * * 调用webservice测试类 */class Test extends CI_Controller&#123; public function __construct() &#123; parent::__construct(); &#125; public function index() &#123; /** * nusoap.php需在网上下载，并将该php文件包含进项目空间 * 引入nusoap.php，调用call()方法 */// require_once (\"libs/nusoap.php\");//// // Create the client instance// $client = new nusoap_client('http://localhost:8080/WeixinDemo/UserInfoPort?wsdl', true);// $client-&gt;soap_defencoding = 'utf-8';// $client-&gt;decode_utf8 = false;// $client-&gt;xml_encoding = 'utf-8';//// $param = array('arg0'=&gt;'Joryun', 'arg1'=&gt;'666666');//webservice参数数组// $result = $client-&gt;call('ParameterTest', $param);//接口和参数// print_r($result); /** * php5自带函数测试 * classMap方式传值 */ $client = new SoapClient(\"http://localhost:8080/WeixinDemo/UserInfoPort?wsdl\"); echo (\"SOAP服务器提供的开放Function:\"); echo '&lt;pre&gt;'; var_dump ( $client-&gt;__getFunctions () );//获取服务器上提供的方法 echo '&lt;/pre&gt;'; echo '&lt;br&gt;'; echo (\"SOAP服务器提供的Type:\"); echo '&lt;pre&gt;'; var_dump ( $client-&gt;__getTypes () );//获取服务器上数据类型 echo '&lt;/pre&gt;'; $object=new stdclass; $object-&gt;arg0='Joryun'; $object-&gt;arg1='666666'; $result = $client-&gt;ParameterTest($object); //$result=get_object_vars($result); //将object转换为array var_dump($result); &#125;&#125;?&gt; 总结好了，今天的教程就说到这里了&lt;(￣︶￣)&gt;当然了，之所以想分享是因为其中是有一些坑在，搞了一天多才搞定了。欢迎大家交流，有啥指导直说无妨哈哈哈哈~~ 愿全天下的代码均不负辛勤的程序员！ CSDN：Joryun’s CSDN 简书：简书","categories":[{"name":"Coding","slug":"Coding","permalink":"http://joryun.com/categories/Coding/"}],"tags":[{"name":"java","slug":"java","permalink":"http://joryun.com/tags/java/"},{"name":"webservice","slug":"webservice","permalink":"http://joryun.com/tags/webservice/"},{"name":"php","slug":"php","permalink":"http://joryun.com/tags/php/"}]}]}